import tkinter as tk
from tkinter import messagebox, ttk
import random

class MazeGame:
    def __init__(self, root, cols=21, rows=15, cell_size=30, time_limit_sec=30, num_exits=2):
        self.root = root
        self.root.title("Побег из Лабиринта")
        self.cols = cols if cols % 2 == 1 else cols + 1
        self.rows = rows if rows % 2 == 1 else rows + 1
        self.cell_size = cell_size
        self.time_limit = time_limit_sec
        self.num_exits = max(1, int(num_exits))

        self._setup_styles()
        w, h = self.cols * self.cell_size, self.rows * self.cell_size
        self.canvas = tk.Canvas(root, width=w, height=h, bg="#fff7e6",
                                highlightthickness=4, highlightbackground="#e0d7c6")
        self.canvas.pack(pady=10)

        btn_frame = tk.Frame(root, bg="#f4efe6")
        btn_frame.pack(pady=(0, 6))
        ttk.Button(btn_frame, text="Новая игра", command=self.reset_game,
                   style="Accent.TButton").pack(side=tk.LEFT, padx=6)
        ttk.Button(btn_frame, text="Играть", command=self.start_search,
                   style="Accent.TButton").pack(side=tk.LEFT, padx=6)

        self.timer_label = tk.Label(root, text="Время: -- с",
                                    font=("Segoe UI", 12, "bold"), bg="#f4efe6")
        self.timer_label.pack()
        self.hint_label = tk.Label(root, text="Нажмите Играть, чтобы начать побег",
                                   font=("Segoe UI", 9), bg="#f4efe6")
        self.hint_label.pack(pady=(4, 8))

        self.reset_game()

    def _setup_styles(self):
        style = ttk.Style()
        try:
            style.theme_use('clam')
        except Exception:
            pass
        style.configure("Accent.TButton", foreground="#ffffff", background="#4b8bbe",
                        font=("Segoe UI", 10, "bold"), padding=6)
        style.map("Accent.TButton", background=[('active', '#3a6f9a'), ('disabled', '#9fb6d0')])

        self.exit_font = ("Segoe UI", 10, "bold")
        self.player_outline = "#ffffff"
        self.player_fill = "#ff8c00"
        self.wall_fill = "#2b2b2b"
        self.trail_fill = "#6aa0ff"
        self.shadow_fill = "#222222"
        self.exit_bg = "#fff1f0"
        self.exit_text = "#c62828"

    def reset_game(self):
        if getattr(self, 'moving', False):
            return
        self.game_over = False
        self.moving = False
        self.remaining = self.time_limit
        self.timer_label.config(text="Время: -- с")
        self.generate_maze()
        self.draw_maze()
        self.draw_player()
        self.canvas.delete("trail")

    def generate_maze(self):
        self.maze = [[True] * self.cols for _ in range(self.rows)]

        def carve(x, y):
            self.maze[y][x] = False
            dirs = [(0, -2), (0, 2), (-2, 0), (2, 0)]
            random.shuffle(dirs)
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 < nx < self.cols - 1 and 0 < ny < self.rows - 1 and self.maze[ny][nx]:
                    self.maze[y + dy // 2][x + dx // 2] = False
                    carve(nx, ny)

        carve(1, 1)

        passages = [(x, y)
                    for y in range(1, self.rows - 1)
                    for x in range(1, self.cols - 1)
                    if not self.maze[y][x]]

        if passages:
            k = min(self.num_exits, len(passages))
            self.exit_positions = random.sample(passages, k)
            start_candidates = [p for p in passages if p not in self.exit_positions]
            if start_candidates:
                self.player_pos = random.choice(start_candidates)
            else:
                fallback = [p for p in passages if p != self.exit_positions[0]]
                self.player_pos = random.choice(fallback) if fallback else passages[0]
        else:
            self.player_pos = (1, 1)
            self.exit_positions = [(self.cols - 2, self.rows - 2)]

    def draw_maze(self):
        self.canvas.delete("all")
        for y in range(self.rows):
            for x in range(self.cols):
                if self.maze[y][x]:
                    cx, cy = x * self.cell_size, y * self.cell_size
                    self.canvas.create_rectangle(cx, cy, cx + self.cell_size, cy + self.cell_size,
                                                 fill=self.wall_fill, outline="")

        for ex, ey in self.exit_positions:
            x0, y0 = ex * self.cell_size, ey * self.cell_size
            self.canvas.create_rectangle(x0 + 2, y0 + 2, x0 + self.cell_size - 2, y0 + self.cell_size - 2,
                                         fill=self.exit_bg, outline="")
            cx, cy = ex * self.cell_size + self.cell_size // 2, ey * self.cell_size + self.cell_size // 2
            self.canvas.create_text(cx, cy, text="Выход", fill=self.exit_text, font=self.exit_font)

    def draw_player(self):
        if hasattr(self, '_player_id'):
            self.canvas.delete(self._player_id)
            self.canvas.delete("player_shadow")
        x, y = self.player_pos
        cx, cy = x * self.cell_size + self.cell_size // 2, y * self.cell_size + self.cell_size // 2
        r = self.cell_size * 0.35
        self.canvas.create_oval(cx - r + 2, cy - r + 2, cx + r + 2, cy + r + 2,
                                fill=self.shadow_fill, outline="", tags="player_shadow")
        self._player_id = self.canvas.create_oval(cx - r, cy - r, cx + r, cy + r,
                                                  fill=self.player_fill, outline=self.player_outline, width=2)

    def tick_timer(self):
        if not self.game_over:
            self.remaining = max(0, self.remaining - 1)
            self.timer_label.config(text=f"Время: {self.remaining:02d} с")
            if self.remaining == 0:
                self.end_game(win=False)
        if not self.game_over:
            self.root.after(1000, self.tick_timer)

    def end_game(self, win):

        self.game_over = True
        self.moving = False
        msg = "Вы сбежали!" if win else "Вы потерялись..."
        messagebox.showinfo("Победа!" if win else "Проигрыш", msg)

    def start_search(self):
        if self.moving or self.game_over:
            return
        self.moving = True
        self.tick_timer()
        self.path_stack = [self.player_pos]
        self.seen = {self.player_pos}
        self.advance_search()

    def advance_search(self):
        if self.game_over or not self.moving:
            return
        if not self.path_stack:
            return

        current = self.path_stack[-1]
        self.player_pos = current
        self.draw_player()

        x, y = current
        cx, cy = x * self.cell_size + self.cell_size // 2, y * self.cell_size + self.cell_size // 2
        r = self.cell_size * 0.12
        self.canvas.create_oval(cx - r, cy - r, cx + r, cy + r, fill=self.trail_fill, outline="", tags="trail")

        if current in self.exit_positions:
            self.end_game(win=True)
            return

        neighbors = []
        for dx, dy in [(0, -1), (1, 0), (0, 1), (-1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < self.cols and 0 <= ny < self.rows:
                if not self.maze[ny][nx] and (nx, ny) not in self.seen:
                    neighbors.append((nx, ny))

        if neighbors:
            next_cell = random.choice(neighbors)
            self.seen.add(next_cell)
            self.path_stack.append(next_cell)
        else:
            self.path_stack.pop()

        self.root.after(200, self.advance_search)


if __name__ == "__main__":
    root = tk.Tk()
    root.configure(bg="#f4efe6")
    game = MazeGame(root, cols=21, rows=15, cell_size=30, time_limit_sec=30, num_exits=2)
    root.mainloop()
